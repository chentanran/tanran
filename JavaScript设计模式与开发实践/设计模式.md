# 单例模式

## 定义

+ 保证一个类仅有一个实例, 并提供一个访问它的全局访问点

# 策略模式

## 定义

+ 定义一系列的算法, 把它们一个个封装起来,并且使它们可以相互替换

+ 策略模式的程序至少由两部分组成: 第一部分是一组策略类,策略类封装了具体的算法, 并负责具体的计算过程;第二部分是环境类context,context接收客户的请求,随后把请求委托给某个策略类

# 代理模式

## 定义

+ 代理模式是为一个对象提供一个代用品或占位符,以便控制对它的访问

# 迭代器模式

## 定义

+ 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示
+ 迭代器模式可以把迭代的过程从业务中分离出来, 在使用迭代器模式之后, 即使不关心对象的内部构造,也可以按顺序访问其中的每个元素

# 发布-订阅模式

## 定义

+ 发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象发生改变时, 所有依赖于它的对象都将得到通知.在javascript中,一般用事件模型代替传统的发布-订阅者模式

# 命令模式

+ 命令模式中的命令指的是一个执行某些特定事情的指令

+ 引用场景: 有时需向某些对象发生请求,但并不知道请求的接收者是谁,也不知道被请求的操作是什么. 此时希望用一种松耦合的方式来设计程序, 使得请求发送者和请求接受者能够消除彼此之间的耦合关系

# 组合模式

+ 小的子对象来构建更大的对象, 而这些小的子对象也许由更小的孙对象构成

# 模板方法模式

## 定义

+ 只需使用继承即可实现的简单的模式

+ 由两部分组成: 1.抽象的父类, 2.具体实现的子类. 通常在抽象的父类中封装了子类的算法框架, 包括实现一些公共方法及封装子类中所有方法的执行顺序. 子类通过继承这个抽象类, 也继承了整个算法结构, 并且可以选择重写父类的方法

# 享元模式

+ 享元模式是一种用于性能优化的模式

+ 核心是运用共享技术来支持大量细粒度的对象

# 责任链模式

## 定义

+ 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系, 将这些对象连成一条链, 并延着这条链传递该请求, 直到有一个对象处理它为止.

# 中介者模式

## 定义

+ 中介者模式的作用就是解除对象与对象之间的耦合关系. 增加一个中介对象后, 所有的相关对象都通过中介者对象来通信,而不是互相引用, 所以当一个对象发生改变时,只需要通知中介者对象即可. 中介者使各对象之间耦合松散,而且可以独立的改变它们之间的交互. 中介者模式使网状的多对多关系变成了相对简单的一对多关系.

# 装饰者模式

## 定义

+ 装饰着模式可以动态的给某个对象添加一些额外的职责,而不会影响从这个类中派生的其他对象

## 状态模式

## 定义

+ 状态模式的关键是区分事物内部的状态, 事物内部状态的改变往往会带来事物的行为改变
